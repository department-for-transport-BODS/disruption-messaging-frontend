import { BehaviorSubject, Observable, Subject } from 'rxjs';
import { HttpErrorResponse } from '@angular/common/http';
import { map, tap } from 'rxjs/operators';
import { Crud, List } from '../types/crud';
import { MutationResponse, MutationResponseType } from '../types/graphql';
import { ApolloQueryResult } from 'apollo-client';
import { ViewModelMapper } from '../types/viewmodel-mapper';
import { Mutation, Query } from 'apollo-angular';
import { keys } from 'lodash';


/*
	Class that manages generic CRUD operations for components. Its extended by the APIService class to provide a complete
	CRUD workflow for components that need it.

	@typeparam T The response type for the resource as generated by graphql-codegen, for example IOrganisationType.
	@typeparam M The view-model for the type as mapped by the classes extending ViewModelMapper

	Usage notes:
	- Extend this class and pass it a mapper extended from ViewModelMapper. The response type and view model of the resource
	  needs to be passed as types to instantiate the class.
	- Components can subscribe to errors$ and serverResponse$ observables to get the errors and response for a mutation.
	- Components can set a resource for edit or delete using the selectForEdit and selectForDelete setters. These values are
	  then available via the selectForEdit$ and selectForDelete$ observables thus allowing communication between a list
	  component and an edit or delete component.

	Example:
	 When a user clicks the edit button on the list component, the list component will call apiServiceController.selectForEdit.
	 The edit component will listen to apiServiceController.selectForEdit$ to get this resource and open the edit form. The edit
	 component will also subscribe to errors$ and serverReponse$ observables to get errors and response for the mutation operation.
 */
export class ApiController<T, M> {
	private errorSubject = new BehaviorSubject<string>(null);
	private mutationResponseSubject = new BehaviorSubject<M | MutationResponseType<T>>(null);
	protected loadingSubject = new BehaviorSubject<boolean>(false);
	private editSubject = new Subject<M>();
	private deleteSubject = new Subject<M>();

	constructor(protected mapper: ViewModelMapper<T, M>) {}

	private _getDataProp(result: MutationResponse<T>): string {
		const data = result.data;
		if (data) {
			return keys(data)[0];
		}
	}

	/* Observable that emits errors with a mutation
	* @returns Observable<string>
	* */
	get errors$(): Observable<string> {
		return this.errorSubject.asObservable();
	}

	/* A setter function to set an error string which will be then available via the errors$ observable. */
	set errors(val: string) {
		this.errorSubject.next(val);
	}

	/* Observable that emits a API mutation response */
	get serverResponse$(): Observable<any> {
		return this.mutationResponseSubject.asObservable();
	}

	/* A setter function to set a mutation response */
	set serverResponse(val: M | MutationResponseType<T>) {
		this.mutationResponseSubject.next(val);
	}

	/* A getter to get the loading status of a resource. */
	get loading$(): Observable<boolean> {
		return this.loadingSubject.asObservable();
	}

	/* An observable that emits a resource view-model ready for edit */
	selectForEdit$(): Observable<M> {
		return this.editSubject.asObservable();
	}

	/* Set a resource view-model to make it available on the selectForEdit$ Observable */
	set selectForEdit(val: M) {
		this.editSubject.next(val);
	}

	/* An observable that emits a resource view-model ready for delete */
	selectForDelete$(): Observable<M> {
		return this.deleteSubject.asObservable();
	}

	set selectForDelete(val: M) {
		this.deleteSubject.next(val);
	}

	protected responseHandler(res: MutationResponse<T>) {
		if (res.errors) {
			return this.errorSubject.next(res.errors.map(err => err.message).join('; '));
		}
		if (res.data) {
			const dataProp = this._getDataProp(res);
			const apiResponse = res.data[dataProp] as MutationResponseType<T>;
			if (apiResponse.data) {
				this.mutationResponseSubject.next(this.mapper.getModel(apiResponse.data));
			} else if (apiResponse.success) {
				this.mutationResponseSubject.next(apiResponse);
			} else if (apiResponse.errors) {
				this.errorSubject.next(apiResponse.errors);
			}
		}
	}

	protected errorHandler(error: HttpErrorResponse) {
		if (error.error.errors) {
			this.errorSubject.next(error.error.errors.map(e => e.message).join(';'));
		} else {
			this.errorSubject.next(error.status + error.statusText);
		}
	}

	resetSubjects() {
		this.mutationResponseSubject.next(null);
		this.errorSubject.next(null);
	}
}

/* The base class for GraphQL CRUD operations. Extends APIServiceController to manage the complete CRUD workflwo.

	@typeparam T: The resource response type, example IOrganisationType
	@typeparam M: The view-model of the resource, example OrganisationViewModel
	@typeparam C: The input parameter type for a create operation, example IOrganisationType
	@typepara U: The input parameter type for an update operation, example IOrganisationType. This defaults to C if both C and U are
		the same.

	Usage notes:
		Extend this class to get a CRUD workflow for your service. See APIController class documentation usage notes to see
		how to use this class for communicating between list and edit components.

	Assumptions:
		The inherent assumption is that components and services that use this class follow the standard CRUD UI workflow.
		A list of resource is displayed using a list component with edit, delete and create buttons. One clicking any of those buttons,
		an add or edit form is opened (for deletions it will a confirmation dialogue). This component exposes both the graphQL
		query and mutation functions and observables to allow for communication between query and mutation components.
 */
export class ApiService<T, M, C, U = C> extends ApiController<T, M> implements Crud<C, U, M> {
	constructor(
			private listQuery: Query,
			private createQuery: Mutation,
			private updateQuery: Mutation,
			private deleteQuery: Mutation,
			protected mapper: ViewModelMapper<T, M>) {
		super(mapper);
	}

	list(): Observable<M[]> {
		return this.listQuery
		.watch()
		.valueChanges
		.pipe(tap((result) => this.loadingSubject.next(result.loading)))
		.pipe(
			map(result => {
				const data = result.data as ApolloQueryResult<T>;
				if (data) {
					const dataProp = keys(data)[0];
					return result.data[dataProp].map(entry =>
						this.mapper.getModel(entry as T));
				}
			}));
	}

	create(params: C) {
		this.loadingSubject.next(true);
		this.createQuery
			.mutate(
			{params},
			{refetchQueries: [{query: this.listQuery.document}]})
			.pipe(tap(() => this.loadingSubject.next(false)))
			.subscribe(
				res => (this.responseHandler(res as MutationResponse<T>)),
			({networkError}) => this.errorHandler(networkError)
			);
	}

	update(id: number, params: U) {
		this.loadingSubject.next(true);
		this.updateQuery
		.mutate(
		{id, params},
		{refetchQueries: [{query: this.listQuery.document}]})
		.pipe(tap(() => this.loadingSubject.next(false)))
		.subscribe(
			res => (this.responseHandler(res as MutationResponse<T>)),
			({networkError}) => this.errorHandler(networkError)
		);
	}

	delete(entryId) {
		const id = parseInt(entryId, 10);
		this.loadingSubject.next(true);
		this.deleteQuery
		.mutate(
			{id}, {refetchQueries: [{query: this.listQuery.document}]})
		.pipe(tap(() => this.loadingSubject.next(false)))
		.subscribe(
			res => this.responseHandler(res as MutationResponse<T>),
			({networkError}) => this.errorHandler(networkError)
		);
	}
}

export class ApiListService<T, M> extends ApiController<T, M> implements List<M> {

	constructor(
			private listQuery: Query,
			protected mapper: ViewModelMapper<T, M>) {
		super(mapper);
	}

	list(): Observable<M[]> {
		return this.listQuery
			.watch()
			.valueChanges
			.pipe(tap((result) => this.loadingSubject.next(result.loading)))
			.pipe(
				map(result => {
					const data = result.data as ApolloQueryResult<T>;
					if (data) {
						const dataProp = keys(data)[0];
						return result.data[dataProp].map(entry =>
							this.mapper.getModel(entry as T));
					}
				}));
	}
}
